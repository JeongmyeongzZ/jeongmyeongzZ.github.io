---
layout: post
title:  "이직 후 새로운 기술 및 용어 정리"
date:   2021-05-20 00:40:12
---

## 기술

---

### Kafka

> Pub-sub`Publish - Subscribe (발행/구독)`모델의 분산 메시징 시스템 (메시지 큐). 

`producer`는 `broker`를 통해 `topic`에 `event(message)`를 `publish`하고, 
`consumer`는 해당 `topic`을 `subscribe`해 `broker`에서 `event(message)`를 가져와(`poll`) 처리한다.

기존의 메시징 시스템의 경우 브로커가 컨슈머에게 데이터를 전달해주는 "Push 방식"을 채택한 경우가 많이 있지만. 카프카는 컨슈머가 브로커에게서 메시지를 가져오는 "Pull 방식"을 채택했다.

이러한 방식은 Loosely coupled, Scalable, 관심사 (interest)에 집중할 수 있다는 장점이 있다.

<br>

topic 은 여러 파티션(partition) 으로 나눠질 수 있는데, 파티션에는 메시지가 Round-robin(RR) 방식으로 쓰여진다. 순차적으로 메시지가 쓰여지지 않을 수 있다는 점을 인지하자.

가용성을 위해 Consumer group을 구성할 수 있으며, 여러 consumer가 동일한 partition 을 바라볼 수는 없다. (메시지 처리 순서 보장)

한 partition 을 담당하는 consumer 가 다운되면, group 내의 다른 consumer가 다시 처리할 수 있다, 이를 Rebalance 라고 한다. 

Zookeper 와 같은 분산 어플리케이션을 위한 코디네이션 시스템을 통해 이전에 소비했던 offset 위치를 기억하고, 혹시나 consumer가 죽었다가 다시 살아나도, 마지막으로 읽었던 위치에서 부터 다시 읽어들일 수 있다. (fail over 신뢰)

그 외 Broker, Controller broker 장애등은 [링크](https://velog.io/@jwpark06/%EC%9E%A5%EC%95%A0%EC%97%90-%EB%8C%80%EC%9D%91%ED%95%98%EB%8A%94-Kafka) 를 참고해보자.

_항상 정보가 최신일거라는 신뢰를 위한 방식의 `zero payload` 방식도 참고 해보자._

---

### Zipkin

> MSA 환경에서 어느 구간에서 이슈가 발생했는지 추적하기 위해 '분산 로그 추적 시스템' 중 하나, 트위터에서 개발 된 가장 활성화 된 오픈소스

클라이언트가 서버로 호출한 하나의 호출을 `Trace` 라고 했을 때, 서비스간의 호출을 `Span`이라고 한다. 

각 서비스 컴포넌트들은 하나의 클라이언트 호출을 추적하기 위해서 같은 `Trace Id`를 사용하고, 각 서비스간의 호출은 각각 다른 `Span Id`를 사용한다. 이렇게 함으로써 전체 트렌젝션 시간을 `Trace`로 추적이 가능하고, 각 서비스별 구간 시간은 `Span`으로 추적할 수 있다.

이 추적은 HTTP request가 들어오는 시점과 HTTP request가 다른 서비스로 나가는 부분을 랩핑하여 Trace와 Span Context를 Header 를 통해 전달하는 방식으로 처리된다.

Zipkin 라이브러리는 수집된 트렌젝션 정보를 zipkin 서버의 collector 모듈로 전송한다. 이 때 다양한 프로토콜을 사용할 수 있는데, 일반적으로 HTTP를 사용하고, 시스템의 규모가 클 경우에는 Kafka 큐를 넣어서 Kafka 프로토콜로 전송이 가능하다.

In-memory, MySQL, Cassandra, Elastic Search 스토리지를 사용할 수 있다.

_driver = noop 등 옵션들을 살펴볼 것,  cassandra (카산드라 부하 방지를 위해 kafka 로 쏘는 등의 처리 가능) 도 !_

---

### API Gateway

> API 서버들의 end-point 를 단일화 해주는 서버

객체 지향의 Facade Pattern 과 유사하지만, 이는 분산 된 시스템의 일부라는 점이 다르다. 클라이언트 앱의 요구사항을 반영해 설계 되었다면 [BFF](https://samnewman.io/patterns/architectural/bff/) 와도 유사하다고 볼 수 있다.


인증 및 인가, 요청 절차의 단순화, 모니터링, 라우팅 및 로드밸런싱, 시스템의 내부 아키텍처 은닉, 캐싱 등의 장점이 있다.

API Gateway 서비스를 사용하면, 내부에 인증 서비스를 추가로 제공하는 경우가 대부분이며, 특정 Domain, 지정된 IP 에만 접근이 가능하도록 private 하게 처리하는 ACL 방법도 있다. 

OAuth2 방식 JWT 를 이용해 인증을 구현하는 게 보편적이다.

---

### SAGA Pattern

> 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴

MSA 환경에서 여러 서비스간의 데이터 일관성이 유지 될 필요가 있는 상황이 있다. 이러한 분산 트랜잭션 관리에 대해 보통 2PC`two phase commit` 와 같은 기법이 사용되곤 했다.

```
2PC 란 일반 Commit 과정에 추가로 Prepare Phase 가 추가적으로 존재해 붙은 이름이다.

Transaction Coordinatior 가 여러 노드에 Prepare 명령을 전달하고, Prepared Ack 을 전달받는 방식.
```

각 서비스의 일부 장애나, 각 서비스의 Lock 사용이 시스템 안정과 퍼포먼스 부분에 문제가 있기에 고안 된 방법이 SAGA 패턴이다.

SAGA 패턴은 트랜잭션 관리 주체가 DBMS 가 아닌 Application 에 있다. 각 App 은 local transaction 만 관여해 처리하며, 처리가 완료 됐다는 Event 를 다른 Application 에 전달한다.

실패 Event 또한 존재하며, 이 실패 케이스를 위한 Rollback 처리(보상 트랜잭션)를 Application 에 구현해야한다.

Kafka와 같은 메시지 큐를 이용해서 비동기 방식으로 Event를 전달하는 Choreography-Based Saga 방식과,

트랜잭션 처리를 위한 Saga 인스턴스(Manager)가 별도로 존재하는 Orchestration-Based Saga 방식이 있다.

---

### Hexagonal Architecture

> 고수준의 비지니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부 영역으로 나눈 아키텍처

Port & Adapter Architecture 라고도 부르는 이 방식은 계층형 구조(Layered Architecture)의 DIP 원칙을 만족하지 못하는 상황에서 고안됐다.

계층형 구조에서 DIP 원칙을 만족시키기 위해 Interface 등을 통해 의존성을 줄인다. 그렇지만 이 방식으로 프로그램을 구현할 때 OCP 원칙을 만족시키는 경우는 거의 없다.

고수준의 모듈이 저수준 모듈의 변경 등에 영향을 받지 않아야 되는데, 이런 경우가 거의 없다는 것이다. 

헥사고널 구조는 고수준의 내부 영역이 어댑터에 전혀 의존하지 않게 한다는 것이 목적이다. 

외부에서 들어오는 요청을 처리하는 인 바운드 어댑터(Inbound Adapter)와 비지니스 로직에 의해 호출되어 외부와 연계되는 아웃바운드(Outbound Adapter) 어댑터로 구성 된 외부 영역,

순수한 비지니스로직, 외부영역과 연계되는 포트로 구성된 내부영역으로 냐눠져있다.

이 포트에도 인 바운드 포트, 아웃바운드 포트가 있는데, 외부 영역의 인 바운드 어댑터가 호출하는 인 바운드 포트는 내부 영역 사용을 위해 표출된 API이며, 아웃바운드 포트는 내부 영역이 외부를 호출하는 방법을 정의한다.

여기서 DIP 원칙과 같이 아웃바운드 포트(상위 모듈, 고수준 모듈)가 외부의 아웃바운드 어댑터(하위 모듈, 저수준 모듈)를 호출하여 외부 시스템과 연계하는 것이 아니라 아웃바운드 어댑터가 아웃바운드 포트에 의존하여 구현된다.

---

### Consul

> 클라우드 환경에서 MicroService Architecture 에서 서비스간 통신을 위한 메커니즘 구현을 쉽게 해주는 툴

클라우드 운영 모델에서 서비스 기반 네트워킹을 위한 중앙 서비스 레지스트리로서 클라우드 네트워크 자동화의 기반을 제공한다.

Service Registry, Health monitoring, Network middleware automation, Zero trust network with service mesh (사이드카 프록시) 등의 기능이 있는데, 현재 Service Registry, RCS(Remote Configuration Server) 용도로 사용중이다.

환경설정 속성들은 주로 dev, beta, prod 등과 같이 여러 개의 프로파일로 운영되는데, 이런 속성들은 마이크로서비스 인스턴스가 많을 땐 관리가 어려워진다. 이 속성들을 외부화하고 중앙 집중화해서 여러 환경에 배포되는 Client 에 적절하게 사용할 수 있다.

---


- fluentd
- envoy
- sidecar
- service mesh, spring cloud nteflix
- sail
- rancher
- datadog
- newrelic
- harbor
  -l4,l7
  -nexus
- on demand
- kafka connect
  - kafka streams
- CDC (Change data capture) 방식
- lottie


<br><br>

## AWS Service

---

- EBS EFS S3(ES ?) (https://seohyun0120.tistory.com/entry/AWS-EBS-vs-EFS-vs-S3-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%96%B4%EB%8A%90-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C)
- ECR
- ECS (https://waspro.tistory.com/428)
- Redshift
- aurora, dynamo, document db
- on demand ec2
- elastic cache
- IAM
- Codebuild, CodeDeploy
- filebeat, elastic search, kibana, logstash
  - kibana index pattern
  - elk, efk
- dms

<br><br>

## 여러 용어

---

- 아젠다
- MVP
- TF


<br>

_참고_
- Kafka
  - _https://bcho.tistory.com/1016_
  - _https://medium.com/@umanking/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-%ED%95%98%EA%B8%B0%EC%A0%84%EC%97%90-%EB%A8%BC%EC%A0%80-data%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EB%B3%B4%EC%9E%90-d2e3ca2f3c2_
  - _https://sowhat4.tistory.com/71_
  - _https://velog.io/@jwpark06/%EC%9E%A5%EC%95%A0%EC%97%90-%EB%8C%80%EC%9D%91%ED%95%98%EB%8A%94-Kafka_
  
- MSA, API gateway
  - _https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern_
  
- Clean Architecture, hexagonal
 - _https://engineering-skcc.github.io/microservice%20inner%20achitecture/inner-architecture-2/_
<br><br><br>
